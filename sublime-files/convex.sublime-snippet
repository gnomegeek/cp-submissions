<snippet>
  <content><![CDATA[
struct point {
    int x, y;
    bool operator<(point& p) { return p.x == x ? y < p.y : x < p.x; }
    bool operator==(point& p) { return (x == p.x and y == p.y); }
};

int cross(point a, point b, point c) {
    point ab, bc;
    ab.x = b.x - a.x, ab.y = b.y - a.y;
    bc.x = c.x - b.x, bc.y = c.y - b.y;
    return ab.x * bc.y - ab.y * bc.x;
}

bool cw(point a, point b, point c) { return cross(a, b, c) < 0; }
bool ccw(point a, point b, point c) { return cross(a, b, c) > 0; }
bool col(point a, point b, point c) { return cross(a, b, c) == 0; }

void convexhull(vector<point>& convex) {
    sort(convex.begin(), convex.end());
    vector<point> up, down;
    point p1 = convex[0];
    point p2 = convex[convex.size() - 1];
    up.pb(p1);
    down.pb(p1);

    for (int i = 1; i < convex.size(); i++) {
        if (i == convex.size() - 1 || !ccw(p1, convex[i], p2)) {
            while (up.size() >= 2 and
                   ccw(up[up.size() - 2], up[up.size() - 1], convex[i]))
                up.pop_back();
            up.pb(convex[i]);
        }

        if (i == convex.size() - 1 || !cw(p1, convex[i], p2)) {
            while (down.size() >= 2 and
                   cw(down[down.size() - 2], down[down.size() - 1], convex[i]))
                down.pop_back();
            down.pb(convex[i]);
        }
    }
    convex.clear();
    for (point i : up) convex.pb(i);
    for (point i : down) convex.pb(i);
    sort(convex.begin(), convex.end());
    convex.resize(unique(convex.begin(), convex.end()) - convex.begin());
}
]]></content>
  <tabTrigger>convex</tabTrigger>
  <description>convex</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <!-- <scope >source.python</scope > -->
</snippet>