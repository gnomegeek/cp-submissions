{
	"cp": {
		"prefix": "cp",
		"body": [
		  "/* ",
		  "    Common Techniques:",
		  "    - Two Pointers",
		  "    - Binary Search",
		  "    - DP",
		  "    - Graph",
		  "    - Bitmasking",
		  "    - Divide and Conquer",
		  "    - Recursion",
		  "",
		  "    Think Think Think !!!!",
		  "*/",
		  "",
		  "#include <bits/stdc++.h>",
		  "",
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "",
		  "#define int long long",
		  "#define pb push_back",
		  "#define F first",
		  "#define S second",
		  "#define all(x) x.begin(), x.end()",
		  "#define pii pair<int, int>",
		  "",
		  "typedef tree<int, null_type, less<int>, rb_tree_tag,",
		  "             tree_order_statistics_node_update>",
		  "    wowset;",
		  "",
		  "const int INF = 1e18;",
		  "const int mod = 1e9 + 7;",
		  "const int inf = INT_MAX;",
		  "const int modd = 998244353;",
		  "const string yess = \"YES\";",
		  "const string noo = \"NO\";",
		  "int dx[] = {0, 0, 1, -1};",
		  "int dy[] = {1, -1, 0, 0};",
		  "const int maxn = 2e5 + 100;",
		  "",
		  "int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }",
		  "",
		  "int lcm(int a, int b) { return (a / gcd(a, b)) * b; }",
		  "",
		  "int fastexpo(int base, int exp) {",
		  "    int res = 1;",
		  "    while (exp > 0) {",
		  "        if (exp % 2 == 1)",
		  "            res = (res * base);",
		  "        exp = exp >> 1;",
		  "        base = (base * base);",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "int mod_div(int a, int b) { return a * fastexpo(b, mod - 2) % mod; }",
		  "",
		  "bool cases = 1;",
		  "",
		  "void letsGO(int test) {}",
		  "",
		  "signed main() {",
		  "    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
		  "#ifndef ONLINE_JUDGE",
		  "    freopen(\"input.txt\", \"r\", stdin);",
		  "    freopen(\"output.txt\", \"w\", stdout);",
		  "#endif",
		  "    cout << fixed << setprecision(6);",
		  "    int TT = 1, cnt = 0;",
		  "    if (cases) cin >> TT;",
		  "    while (TT--) letsGO(++cnt);",
		  "}"
		],
		"description": "cp"
	  }, 
	  "bellman": {
		"prefix": "bellman",
		"body": [
		  "vector<int> bellman_ford(int n, vector<vector<int>>& edges, int src) {",
		  "    vector<int> dist(n + 1, INF);",
		  "    dist[src] = 0;",
		  "    for (int i = 1; i < n; i++) {",
		  "        for (auto edge : edges) {",
		  "            int u = edge[0], v = edge[1], wt = edge[2];",
		  "            if (dist[u] == INF) continue;",
		  "            if (dist[u] + wt < dist[v]) dist[v] = dist[u] + wt;",
		  "            dist[v] = max(dist[v], -INF);",
		  "        }",
		  "    }",
		  "",
		  "    for (int i = 1; i < n; i++) {",
		  "        for (auto edge : edges) {",
		  "            int u = edge[0], v = edge[1], wt = edge[2];",
		  "            if (dist[u] == INF) continue;",
		  "            if (dist[u] + wt < dist[v]) {",
		  "                dist[v] = -INF;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    return dist;",
		  "}"
		],
		"description": "bellman"
	  }
	  ,
	  "dijkstra": {
		"prefix": "dijkstra",
		"body": [
		  "vector<int> dijkstra(vector<vector<pii>>& graph, int n, int src) {",
		  "    set<pii> xx;",
		  "    vector<int> dis(n + 1, INF), vis(n + 1, 0);",
		  "    dis[src] = 0;",
		  "    for (int i = 1; i <= n; i++) xx.insert({dis[i], i});",
		  "    while (!xx.empty()) {",
		  "        pii cur = *xx.begin();",
		  "        xx.erase(xx.begin());",
		  "        vis[cur.S] = 1;",
		  "        for (auto nbr : graph[cur.S]) {",
		  "            if (!vis[nbr.F]) {",
		  "                auto itr = xx.find({dis[nbr.F], nbr.F});",
		  "                dis[nbr.F] = min(dis[nbr.F], cur.F + nbr.S);",
		  "                xx.erase(itr);",
		  "                xx.insert({dis[nbr.F], nbr.F});",
		  "            }",
		  "        }",
		  "    }",
		  "    return dis;",
		  "}"
		],
		"description": "dijkstra"
	  }
	  ,
	  "floyd": {
		"prefix": "floyd",
		"body": [
		  "void floyd_warshall(vector<vector<int>> &graph, int n) {",
		  "    graph.reisze(n + 1, vector<int>(n + 1, INF));",
		  "    for (int i = 0; i <= n; i++) graph[i][i] = 0;",
		  "    for (int i = 0; i < m; i++) {",
		  "        int a, b, c;",
		  "        cin >> a >> b >> c;",
		  "        graph[a][b] = c;",
		  "        graph[b][a] = c;",
		  "    }",
		  "",
		  "    for (int i = 1; i <= n; i++) {",
		  "        for (int x = 1; x <= n; x++) {",
		  "            for (int y = 1; y <= n; y++) {",
		  "                if (x == i || y == i || x == y) continue;",
		  "                graph[x][y] = min(graph[x][y], graph[x][i] + graph[i][y]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    for (int i = 1; i <= n; i++) {",
		  "        for (int j = 1; j <= n; j++) {",
		  "            graph[i][j] = (graph[i][j] == linf ? -1 : graph[i][j]);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "floyd"
	  } 
	  ,
		"convex": {
		  "prefix": "convex",
		  "body": [
			"struct point {",
			"    int x, y;",
			"    bool operator<(point& p) { return p.x == x ? y < p.y : x < p.x; }",
			"    bool operator==(point& p) { return (x == p.x and y == p.y); }",
			"};",
			"",
			"int cross(point a, point b, point c) {",
			"    point ab, bc;",
			"    ab.x = b.x - a.x, ab.y = b.y - a.y;",
			"    bc.x = c.x - b.x, bc.y = c.y - b.y;",
			"    return ab.x * bc.y - ab.y * bc.x;",
			"}",
			"",
			"bool cw(point a, point b, point c) { return cross(a, b, c) < 0; }",
			"bool ccw(point a, point b, point c) { return cross(a, b, c) > 0; }",
			"bool col(point a, point b, point c) { return cross(a, b, c) == 0; }",
			"",
			"void convexhull(vector<point>& convex) {",
			"    sort(convex.begin(), convex.end());",
			"    vector<point> up, down;",
			"    point p1 = convex[0];",
			"    point p2 = convex[convex.size() - 1];",
			"    up.pb(p1);",
			"    down.pb(p1);",
			"",
			"    for (int i = 1; i < convex.size(); i++) {",
			"        if (i == convex.size() - 1 || !ccw(p1, convex[i], p2)) {",
			"            while (up.size() >= 2 and",
			"                   ccw(up[up.size() - 2], up[up.size() - 1], convex[i]))",
			"                up.pop_back();",
			"            up.pb(convex[i]);",
			"        }",
			"",
			"        if (i == convex.size() - 1 || !cw(p1, convex[i], p2)) {",
			"            while (down.size() >= 2 and",
			"                   cw(down[down.size() - 2], down[down.size() - 1], convex[i]))",
			"                down.pop_back();",
			"            down.pb(convex[i]);",
			"        }",
			"    }",
			"    convex.clear();",
			"    for (point i : up) convex.pb(i);",
			"    for (point i : down) convex.pb(i);",
			"    sort(convex.begin(), convex.end());",
			"    convex.resize(unique(convex.begin(), convex.end()) - convex.begin());",
			"}"
		  ],
		  "description": "convex"
		},
		"kick": {
		  "prefix": "kick",
		  "body": [
			"cout << \"Case #\" << test << \": \" << "
		  ],
		  "description": "kick"
		},
		"suffixarray": {
		  "prefix": "suffixarray",
		  "body": [
			"void radix_sort(vector<pair<pair<int, int>, int>>& v) {",
			"    int n = v.size();",
			"    int mxs = -INF, mxf = -INF;",
			"    for (int i = 0; i < n; i++)",
			"        mxs = max(v[i].F.S, mxs), mxf = max(mxf, v[i].F.F);",
			"    vector<int> count2(mxs + 1, 0);",
			"    vector<int> count1(mxf + 1, 0);",
			"    vector<pair<pair<int, int>, int>> sorted(n);",
			"    vector<int> bucket_idx(mxs + 1, 0);",
			"    for (int i = 0; i < n; i++) count2[v[i].F.S]++;",
			"    for (int i = 1; i < mxs + 1; i++)",
			"        bucket_idx[i] = bucket_idx[i - 1] + count2[i - 1];",
			"    for (int i = 0; i < n; i++) sorted[bucket_idx[v[i].F.S]++] = v[i];",
			"    v = sorted;",
			"    for (int i = 0; i < n; i++) count1[v[i].F.F]++;",
			"    bucket_idx.clear();",
			"    bucket_idx.resize(mxf + 1, 0);",
			"    for (int i = 1; i < mxf + 1; i++)",
			"        bucket_idx[i] = bucket_idx[i - 1] + count1[i - 1];",
			"    for (int i = 0; i < n; i++) sorted[bucket_idx[v[i].F.F]++] = v[i];",
			"    v = sorted;",
			"}",
			"",
			"vector<int> computeSA(string& S) {",
			"    string s = S + '$';",
			"    int n = s.length();",
			"    vector<int> p(n), c(n);",
			"    vector<pair<char, int>> a(n);",
			"    for (int i = 0; i < n; i++) a[i] = {s[i], i};",
			"    sort(a.begin(), a.end());",
			"    for (int i = 0; i < n; i++) p[i] = a[i].S;",
			"    c[p[0]] = 0;",
			"    for (int i = 1; i < n; i++) c[p[i]] = c[p[i - 1]] + (a[i].F != a[i - 1].F);",
			"    int k = 0;",
			"    while ((1 << k) < n) {",
			"        vector<pair<pair<int, int>, int>> v(n);",
			"        for (int i = 0; i < n; i++) v[i] = {{c[i], c[(i + (1 << k)) % n]}, i};",
			"        radix_sort(v);",
			"        for (int i = 0; i < n; i++) p[i] = v[i].S;",
			"        c[p[0]] = 0;",
			"        for (int i = 1; i < n; i++)",
			"            c[p[i]] = c[p[i - 1]] + (v[i].F != v[i - 1].F);",
			"        k++;",
			"    }",
			"    return p;",
			"}"
		  ],
		  "description": "suffixarray"
		}
  }