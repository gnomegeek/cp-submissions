{
  "cp": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "#define int long long",
      "#define pb push_back",
      "#define F first",
      "#define S second",
      "#define all(x) x.begin(), x.end()",
      "#define pii pair<int, int>",
      "",
      "typedef tree<int, null_type, less<int>, rb_tree_tag,",
      "             tree_order_statistics_node_update>",
      "    wowset;",
      "",
      "const int linf = 1000000000000000000LL;",
      "const int mod = 1000000007LL;",
      "const int inf = INT_MAX;",
      "const int modd = 998244353;",
      "const string yess = \"YES\";",
      "const string noo = \"NO\";",
      "",
      "int lcm(int a, int b) { return (a / gcd(a, b)) * b; }",
      "int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }",
      "int fastexpo(int base, int exp) {",
      "    int res = 1;",
      "    while (exp > 0) {",
      "        if (exp % 2 == 1)",
      "            res = (res * base);",
      "        exp = exp >> 1;",
      "        base = (base * base);",
      "    }",
      "    return res;",
      "}",
      "",
      "bool cases = true;",
      "",
      "void letsGO(int test) {}",
      "",
      "signed main() {",
      "    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
      "#ifndef ONLINE_JUDGE",
      "    freopen(\"input.txt\", \"r\", stdin);",
      "    freopen(\"output.txt\", \"w\", stdout);",
      "#endif",
      "    cout << fixed << setprecision(6);",
      "    int TT = 1, cnt = 0;",
      "    if (cases) cin >> TT;",
      "    while (TT--) letsGO(++cnt);",
      "}"
    ],
    "description": "cp"
  }, 
      "convex": {
        "prefix": "convex",
        "body": [
          "struct point {",
          "    int x, y;",
          "    bool operator<(point& p) { return p.x == x ? y < p.y : x < p.x; }",
          "    bool operator==(point& p) { return (x == p.x and y == p.y); }",
          "};",
          "",
          "int cross(point a, point b, point c) {",
          "    point ab, bc;",
          "    ab.x = b.x - a.x, ab.y = b.y - a.y;",
          "    bc.x = c.x - b.x, bc.y = c.y - b.y;",
          "    return ab.x * bc.y - ab.y * bc.x;",
          "}",
          "",
          "bool cw(point a, point b, point c) { return cross(a, b, c) < 0; }",
          "bool ccw(point a, point b, point c) { return cross(a, b, c) > 0; }",
          "bool col(point a, point b, point c) { return cross(a, b, c) == 0; }",
          "",
          "void convexhull(vector<point>& convex) {",
          "    sort(convex.begin(), convex.end());",
          "    vector<point> up, down;",
          "    point p1 = convex[0];",
          "    point p2 = convex[convex.size() - 1];",
          "    up.pb(p1);",
          "    down.pb(p1);",
          "",
          "    for (int i = 1; i < convex.size(); i++) {",
          "        if (i == convex.size() - 1 || !ccw(p1, convex[i], p2)) {",
          "            while (up.size() >= 2 and",
          "                   ccw(up[up.size() - 2], up[up.size() - 1], convex[i]))",
          "                up.pop_back();",
          "            up.pb(convex[i]);",
          "        }",
          "",
          "        if (i == convex.size() - 1 || !cw(p1, convex[i], p2)) {",
          "            while (down.size() >= 2 and",
          "                   cw(down[down.size() - 2], down[down.size() - 1], convex[i]))",
          "                down.pop_back();",
          "            down.pb(convex[i]);",
          "        }",
          "    }",
          "    convex.clear();",
          "    for (point i : up) convex.pb(i);",
          "    for (point i : down) convex.pb(i);",
          "    sort(convex.begin(), convex.end());",
          "    convex.resize(unique(convex.begin(), convex.end()) - convex.begin());",
          "}"
        ],
        "description": "convex"
      },
      "kick": {
        "prefix": "kick",
        "body": [
          "cout << \"Case #\" << test << \": \" << "
        ],
        "description": "kick"
      },
      "suffixarray": {
        "prefix": "suffixarray",
        "body": [
          "void radix_sort(vector<pair<pair<int, int>, int>>& v) {",
          "    int n = v.size();",
          "    int mxs = -INF, mxf = -INF;",
          "    for (int i = 0; i < n; i++)",
          "        mxs = max(v[i].F.S, mxs), mxf = max(mxf, v[i].F.F);",
          "    vector<int> count2(mxs + 1, 0);",
          "    vector<int> count1(mxf + 1, 0);",
          "    vector<pair<pair<int, int>, int>> sorted(n);",
          "    vector<int> bucket_idx(mxs + 1, 0);",
          "    for (int i = 0; i < n; i++) count2[v[i].F.S]++;",
          "    for (int i = 1; i < mxs + 1; i++)",
          "        bucket_idx[i] = bucket_idx[i - 1] + count2[i - 1];",
          "    for (int i = 0; i < n; i++) sorted[bucket_idx[v[i].F.S]++] = v[i];",
          "    v = sorted;",
          "    for (int i = 0; i < n; i++) count1[v[i].F.F]++;",
          "    bucket_idx.clear();",
          "    bucket_idx.resize(mxf + 1, 0);",
          "    for (int i = 1; i < mxf + 1; i++)",
          "        bucket_idx[i] = bucket_idx[i - 1] + count1[i - 1];",
          "    for (int i = 0; i < n; i++) sorted[bucket_idx[v[i].F.F]++] = v[i];",
          "    v = sorted;",
          "}",
          "",
          "vector<int> computeSA(string& S) {",
          "    string s = S + '$';",
          "    int n = s.length();",
          "    vector<int> p(n), c(n);",
          "    vector<pair<char, int>> a(n);",
          "    for (int i = 0; i < n; i++) a[i] = {s[i], i};",
          "    sort(a.begin(), a.end());",
          "    for (int i = 0; i < n; i++) p[i] = a[i].S;",
          "    c[p[0]] = 0;",
          "    for (int i = 1; i < n; i++) c[p[i]] = c[p[i - 1]] + (a[i].F != a[i - 1].F);",
          "    int k = 0;",
          "    while ((1 << k) < n) {",
          "        vector<pair<pair<int, int>, int>> v(n);",
          "        for (int i = 0; i < n; i++) v[i] = {{c[i], c[(i + (1 << k)) % n]}, i};",
          "        radix_sort(v);",
          "        for (int i = 0; i < n; i++) p[i] = v[i].S;",
          "        c[p[0]] = 0;",
          "        for (int i = 1; i < n; i++)",
          "            c[p[i]] = c[p[i - 1]] + (v[i].F != v[i - 1].F);",
          "        k++;",
          "    }",
          "    return p;",
          "}"
        ],
        "description": "suffixarray"
      }
}